name: Jenkins Comment Janitor

on:
  issue_comment:
    types: [created]

jobs:
  deduplicate:
    # Only run if the comment is from the Jenkins bot
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
      # 'issues: write' is required to delete comments

    steps:
      - name: Group, Minimize, and Prune Comments
        uses: actions/github-script@v7
        with:
          script: |
            // ================= DEFAULTS =================
            const JENKINS_USER = 'KennethStubbings';
            let similarityThreshold = 0.95; 
            let deleteAfterLimit = 0; // 0 = Disabled (Infinite history)
            const DRY_RUN = false; 
            // ============================================

            // --- 1. CONFIGURATION PARSING ---
            console.log("[CONFIG] Scanning PR description for 'Jenkins Cleanup Configuration:' block...");
            
            const prBody = context.payload.issue.body || "";
            const lines = prBody.split(/\r?\n/);
            let foundHeader = false;
            const config = {};

            for (const line of lines) {
              const trimmed = line.trim();

              if (!foundHeader) {
                if (trimmed.includes("Jenkins Cleanup Configuration:")) {
                  foundHeader = true;
                }
                continue;
              }

              if (trimmed === "") break; // End of block

              const separatorIndex = trimmed.indexOf('=');
              if (separatorIndex !== -1) {
                const key = trimmed.substring(0, separatorIndex).trim();
                const value = trimmed.substring(separatorIndex + 1).trim();
                config[key] = value;
                console.log(`[CONFIG] Read property: '${key}' = '${value}'`);
              }
            }

            // Apply 'match%'
            if (config['match%']) {
              const parsedVal = parseInt(config['match%'], 10);
              if (!isNaN(parsedVal) && parsedVal > 0 && parsedVal <= 100) {
                similarityThreshold = parsedVal / 100;
                console.log(`[CONFIG] APPLIED: Similarity threshold set to ${parsedVal}%`);
              }
            }

            // Apply 'delete-after'
            if (config['delete-after']) {
              const parsedLimit = parseInt(config['delete-after'], 10);
              if (!isNaN(parsedLimit) && parsedLimit >= 0) {
                deleteAfterLimit = parsedLimit;
                console.log(`[CONFIG] APPLIED: Rolling History Limit. Delete comments after ${deleteAfterLimit} duplicates.`);
              }
            }

            // --- Levenshtein Helper ---
            function levenshtein(a, b) {
              if (a.length === 0) return b.length;
              if (b.length === 0) return a.length;
              const matrix = [];
              for (let i = 0; i <= b.length; i++) matrix[i] = [i];
              for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
              for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                  if (b.charAt(i - 1) === a.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                  } else {
                    matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j] + 1);
                  }
                }
              }
              return matrix[b.length][a.length];
            }

            function getSimilarity(s1, s2) {
              const longer = s1.length > s2.length ? s1 : s2;
              if (longer.length === 0) return 1.0;
              const distance = levenshtein(s1, s2);
              return (longer.length - distance) / longer.length;
            }

            // --- 2. FETCH ALL COMMENTS (GraphQL) ---
            console.log(`Fetching ALL comments for PR #${context.issue.number}...`);
            
            let allComments = [];
            let hasNextPage = true;
            let endCursor = null;

            while (hasNextPage) {
              const query = `
                query($owner: String!, $repo: String!, $number: Int!, $cursor: String) {
                  repository(owner: $owner, name: $repo) {
                    pullRequest(number: $number) {
                      comments(first: 100, after: $cursor) {
                        pageInfo { hasNextPage, endCursor }
                        nodes {
                          id             
                          databaseId     
                          body
                          isMinimized    
                          author { login }
                        }
                      }
                    }
                  }
                }
              `;

              const result = await github.graphql(query, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                number: context.issue.number,
                cursor: endCursor
              });

              const data = result.repository.pullRequest.comments;
              allComments = allComments.concat(data.nodes);
              hasNextPage = data.pageInfo.hasNextPage;
              endCursor = data.pageInfo.endCursor;
            }
            console.log(`[DEBUG] Fetched ${allComments.length} total comments.`);

            // --- 3. FILTER & SORT ---
            // LOGIC CHANGE: If 'delete-after' is set, we MUST include hidden comments 
            // to accurately count the history depth.
            const includeHidden = (deleteAfterLimit > 0);

            const jenkinsComments = allComments
              .filter(c => {
                const isJenkins = c.author && c.author.login === JENKINS_USER;
                if (!isJenkins) return false;
                
                // If we are deleting old ones, we need to see the hidden ones to count them.
                if (includeHidden) return true;
                
                // Default behavior: ignore already minimized ones to save processing
                return !c.isMinimized;
              })
              .sort((a, b) => b.databaseId - a.databaseId); // Newest first

            console.log(`[DEBUG] Processing ${jenkinsComments.length} Jenkins comments.`);

            if (jenkinsComments.length < 2) return;

            // --- 4. CLUSTERING LOGIC ---
            const groups = [];

            for (const comment of jenkinsComments) {
              let placedInGroup = false;
              for (const group of groups) {
                const score = getSimilarity(group.representative.body, comment.body);
                if (score >= similarityThreshold) {
                  group.duplicates.push(comment);
                  placedInGroup = true;
                  break;
                }
              }
              if (!placedInGroup) {
                groups.push({ representative: comment, duplicates: [] });
              }
            }

            // --- 5. BUCKETING (MINIMIZE vs DELETE) ---
            const toMinimize = [];
            const toDelete = [];

            for (const group of groups) {
              const dups = group.duplicates; // These are ordered Newest -> Oldest
              
              if (dups.length === 0) continue;

              if (deleteAfterLimit > 0) {
                // Rolling History Logic
                // Example: Limit 5. We have 10 duplicates.
                // Keep the first 5 (indices 0-4) as history (Minimize them).
                // Delete the rest (indices 5-9).
                
                const keepAsHistory = dups.slice(0, deleteAfterLimit);
                const garbage = dups.slice(deleteAfterLimit);

                // Only add to 'toMinimize' if they aren't already minimized
                toMinimize.push(...keepAsHistory.filter(c => !c.isMinimized));
                
                toDelete.push(...garbage);
                
                if (garbage.length > 0) {
                  console.log(`Group ${group.representative.databaseId}: Keeping ${keepAsHistory.length} history items, deleting ${garbage.length} old items.`);
                }
              } else {
                // Default Logic: Minimize everything
                toMinimize.push(...dups.filter(c => !c.isMinimized));
              }
            }

            // --- 6. EXECUTE ACTIONS ---
            
            // A. DELETION
            if (toDelete.length > 0) {
              console.log(`\n--- DELETING ${toDelete.length} COMMENTS ---`);
              if (!DRY_RUN) {
                for (const comment of toDelete) {
                  try {
                    // Using REST API for deletion (Simpler)
                    await github.rest.issues.deleteComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      comment_id: comment.databaseId,
                    });
                    console.log(`Deleted comment ${comment.databaseId}`);
                  } catch (error) {
                    console.error(`Error deleting ${comment.databaseId}:`, error);
                  }
                }
              } else {
                console.log(`[DRY RUN] Would delete ${toDelete.length} comments.`);
              }
            }

            // B. MINIMIZATION
            if (toMinimize.length > 0) {
              console.log(`\n--- MINIMIZING ${toMinimize.length} COMMENTS ---`);
              if (!DRY_RUN) {
                for (const comment of toMinimize) {
                  const mutation = `
                    mutation($subjectId: ID!) {
                      minimizeComment(input: { subjectId: $subjectId, classifier: OUTDATED }) {
                        clientMutationId
                      }
                    }
                  `;
                  try {
                    await github.graphql(mutation, { subjectId: comment.id });
                    console.log(`Minimized comment ${comment.databaseId}`);
                  } catch (error) {
                    console.error(`Error minimizing ${comment.databaseId}:`, error);
                  }
                }
              } else {
                console.log(`[DRY RUN] Would minimize ${toMinimize.length} comments.`);
              }
            }
