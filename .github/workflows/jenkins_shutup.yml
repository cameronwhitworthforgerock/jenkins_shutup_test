name: Jenkins Comment Janitor

on:
  issue_comment:
    types: [created]

jobs:
  deduplicate:
    # Only run if the comment is from the Jenkins bot
    # (Note: You might want to remove this 'if' temporarily if testing with your own user)
    # if: github.event.comment.user.login == 'KennethStubbings'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write

    steps:
      - name: Group and Minimize Comments
        uses: actions/github-script@v7
        with:
          script: |
            // ================= CONFIGURATION =================
            const JENKINS_USER = 'KennethStubbings';
            const SIMILARITY_THRESHOLD = 0.80; 
            
            // SET THIS TO TRUE TO TEST WITHOUT HIDING COMMENTS
            const DRY_RUN = false; 
            // =================================================

            // --- Levenshtein Distance Algorithm ---
            function levenshtein(a, b) {
              if (a.length === 0) return b.length;
              if (b.length === 0) return a.length;
              
              const matrix = [];
              for (let i = 0; i <= b.length; i++) matrix[i] = [i];
              for (let j = 0; j <= a.length; j++) matrix[0][j] = j;

              for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                  if (b.charAt(i - 1) === a.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                  } else {
                    matrix[i][j] = Math.min(
                      matrix[i - 1][j - 1] + 1,
                      matrix[i][j - 1] + 1,
                      matrix[i - 1][j] + 1
                    );
                  }
                }
              }
              return matrix[b.length][a.length];
            }

            function getSimilarity(s1, s2, id1, id2) {
              const longer = s1.length > s2.length ? s1 : s2;
              if (longer.length === 0) return 1.0;
              
              const lenDiff = Math.abs(s1.length - s2.length);
              const maxAllowedDiff = longer.length * (1 - SIMILARITY_THRESHOLD);

              // LOGGING: Check if length optimization is triggering
              if (lenDiff > maxAllowedDiff) {
                console.log(`[DEBUG] Skipped comparison between ${id1} and ${id2}.`);
                console.log(`       Reason: Length diff (${lenDiff}) > Allowed (${maxAllowedDiff.toFixed(2)}). Threshold is strict.`);
                return 0; 
              }

              const distance = levenshtein(s1, s2);
              const score = (longer.length - distance) / longer.length;
              return score;
            }

            // 1. Fetch comments
            // Note: We added 'per_page: 100' to try and get more comments, 
            // as the default is often only 30.
            console.log(`Fetching comments for PR #${context.issue.number}...`);
            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              per_page: 100, // Ask for max per page to reduce number of API calls
            });

            console.log(`[DEBUG] Raw API returned ${comments.length} comments.`);

            // 2. Filter Jenkins comments and sort NEWEST first
            const jenkinsComments = comments
              .filter(c => {
                 const isTargetUser = c.user.login === JENKINS_USER;
                 // Debug if 'is_minimized' is actually present
                 if (isTargetUser && c.is_minimized === undefined) {
                    console.log(`[WARNING] Comment ${c.id} has undefined 'is_minimized' property! REST API might not be returning it.`);
                 }
                 return isTargetUser && !c.is_minimized;
              })
              .sort((a, b) => b.id - a.id);
            
            console.log(`[DEBUG] After filtering for user '${JENKINS_USER}' and !minimized: ${jenkinsComments.length} comments remain.`);

            if (jenkinsComments.length < 2) {
              console.log("Not enough comments to group.");
              return;
            }

            // 3. CLUSTERING LOGIC
            const groups = [];

            for (const comment of jenkinsComments) {
              let placedInGroup = false;

              // Check if this comment belongs to an existing group
              for (const group of groups) {
                // Pass IDs to helper for better logging
                const score = getSimilarity(group.representative.body, comment.body, group.representative.id, comment.id);
                
                if (score >= SIMILARITY_THRESHOLD) {
                  group.duplicates.push(comment);
                  placedInGroup = true;
                  console.log(`-> Comment ${comment.id} grouped with ${group.representative.id} (Similarity: ${(score*100).toFixed(2)}%)`);
                  break;
                } else {
                   console.log(`[DEBUG] No match: ${comment.id} vs ${group.representative.id} was only ${(score*100).toFixed(2)}%`);
                }
              }

              if (!placedInGroup) {
                groups.push({
                  representative: comment,
                  duplicates: []
                });
                console.log(`-> New Group Created. Representative: ${comment.id}`);
              }
            }

            // 4. COLLECT TARGETS TO MINIMIZE
            const toMinimize = [];
            for (const group of groups) {
              if (group.duplicates.length > 0) {
                console.log(`Group ${group.representative.id} has ${group.duplicates.length} outdated duplicates.`);
                toMinimize.push(...group.duplicates);
              }
            }

            // 5. EXECUTE MINIMIZATION
            if (toMinimize.length === 0) {
              console.log("No duplicates found to minimize.");
              return;
            }

            console.log(`\nTotal comments to minimize: ${toMinimize.length}`);

            if (DRY_RUN) {
              console.log("DRY RUN ENABLED - No changes made.");
            } else {
              for (const comment of toMinimize) {
                const mutation = `
                  mutation($subjectId: ID!) {
                    minimizeComment(input: { subjectId: $subjectId, classifier: OUTDATED }) {
                      clientMutationId
                      minimizedComment {
                        isMinimized
                      }
                    }
                  }
                `;
                
                try {
                  await github.graphql(mutation, { subjectId: comment.node_id });
                  console.log(`Minimized comment ${comment.id}`);
                } catch (error) {
                  console.error(`Error minimizing ${comment.id}:`, error);
                }
              }
            }
